# Structural Design Patterns

These patterns are responsible for building class hierarchies that are easy to maintain.

## Adapter

Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.

  * [Text material for reference by dofactory](https://www.dofactory.com/net/adapter-design-pattern);
  * [Text material for reference by Refactoring.Guru](https://refactoring.guru/design-patterns/adapter);
  * [Implementation here](https://github.com/MikhailMasny/solid-and-design-patterns/blob/master/src/Masny.Patterns/Structural/AdapterPattern.cs).

## Bridge

Decouple an abstraction from its implementation so that the two can vary independently.

  * [Text material for reference by dofactory](https://www.dofactory.com/net/bridge-design-pattern);
  * [Text material for reference by Refactoring.Guru](https://refactoring.guru/design-patterns/bridge);
  * [Implementation here](https://github.com/MikhailMasny/solid-and-design-patterns/blob/master/src/Masny.Patterns/Structural/BridgePattern.cs).

## Composite

Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.

  * [Text material for reference by dofactory](https://www.dofactory.com/net/composite-design-pattern);
  * [Text material for reference by Refactoring.Guru](https://refactoring.guru/design-patterns/composite);
  * [Implementation here](https://github.com/MikhailMasny/solid-and-design-patterns/blob/master/src/Masny.Patterns/Structural/CompositePattern.cs).

## Decorator

Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.

  * [Text material for reference by dofactory](https://www.dofactory.com/net/decorator-design-pattern);
  * [Text material for reference by Refactoring.Guru](https://refactoring.guru/design-patterns/decorator);
  * [Implementation here](https://github.com/MikhailMasny/solid-and-design-patterns/blob/master/src/Masny.Patterns/Structural/DecoratorPattern.cs).

## Façade

Provide a unified interface to a set of interfaces in a subsystem. Façade defines a higher-level interface that makes the subsystem easier to use.

  * [Text material for reference by dofactory](https://www.dofactory.com/net/facade-design-pattern);
  * [Text material for reference by Refactoring.Guru](https://refactoring.guru/design-patterns/facade);
  * [Implementation here](https://github.com/MikhailMasny/solid-and-design-patterns/blob/master/src/Masny.Patterns/Structural/FacadePattern.cs).

## Flyweight

Use sharing to support large numbers of fine-grained objects efficiently.

  * [Text material for reference by dofactory](https://www.dofactory.com/net/flyweight-design-pattern);
  * [Text material for reference by Refactoring.Guru](https://refactoring.guru/design-patterns/flyweight);
  * [Implementation here](https://github.com/MikhailMasny/solid-and-design-patterns/blob/master/src/Masny.Patterns/Structural/FlyweightPattern.cs).

## Proxy

Provide a surrogate or placeholder for another object to control access to it.

  * [Text material for reference by dofactory](https://www.dofactory.com/net/proxy-design-pattern);
  * [Text material for reference by Refactoring.Guru](https://refactoring.guru/design-patterns/proxy);
  * [Implementation here](https://github.com/MikhailMasny/solid-and-design-patterns/blob/master/src/Masny.Patterns/Structural/ProxyPattern.cs).
